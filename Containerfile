# Allow build scripts to be referenced without being copied into the final image
# This is a special "scratch" stage often used in Universal Blue's image-template.
# It serves as a temporary place to copy build helper scripts (like `build.sh`)
# that are then mounted into later stages, but are not part of the final image.
FROM scratch AS ctx
COPY build_files /

# --- Stage 1: Builder ---
# This stage is dedicated to COMPILING the 'huenicorn' application.
# It uses a full Fedora image because compilation requires various development tools,
# compilers (gcc-c++), and header files (-devel packages).
# IMPORTANT: This stage's image and tools are TEMPORARY and will NOT be part of your final bootc system.
FROM registry.fedoraproject.org/fedora:latest AS builder

# Add RPM Fusion repositories.
# RPM Fusion provides additional software packages not included in the main Fedora repositories,
# often for multimedia codecs or specialized development libraries (like some ffmpeg components).
# We install both 'free' and 'nonfree' versions to ensure all potential dependencies for 'huenicorn'
# (especially related to video/audio processing) are available during compilation.
RUN dnf install -y \
    https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm \
    https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm \
    && dnf update -y

# Copy any necessary custom files into the builder stage.
# This line assumes you have a local directory named 'files/' in the same location as your Containerfile.
# If 'huenicorn' requires specific custom header files, configuration, or data files during its build process
# that are not part of its Git repository, this step would bring them into the build environment.
# If your 'files/' directory only contains content for the *final* system, this line might be removed from here.
COPY files/ /

# Install ALL necessary build dependencies for huenicorn.
# This is a single, efficient 'RUN' command to reduce the number of image layers.
# - git: To clone the huenicorn source code.
# - cmake: A cross-platform build system generator that huenicorn uses.
# - gcc-c++: The C++ compiler.
# - make: A build automation tool that executes instructions from a Makefile generated by CMake.
# - pkgconfig: A helper tool used by build systems (like CMake) to find libraries.
# - curl-devel, json-c-devel, libusbx-devel, etc.: These are development (header) files
#   for libraries that huenicorn depends on. The '-devel' suffix indicates they are for
#   compiling against, not just running.
# - opencv-devel: Specific development files for OpenCV, a crucial dependency for huenicorn.
# - asio-devel, nlohmann-json-devel, mbedtls-devel, libX11-devel, glib2-devel, pipewire-devel,
#   ffmpeg-devel, gstreamer1-plugins-base-devel, libva-devel, libvdpau-devel, mesa-libGL-devel,
#   libdrm-devel, libXext-devel, libXrandr-devel, glm-devel: Other development libraries
#   required for huenicorn's compilation.
# dnf clean all: Cleans up the dnf cache to reduce the final image size of this stage.
RUN dnf update -y && \
    dnf install -y \
        git \
        cmake \
        gcc-c++ \
        make \
        pkgconfig \
        curl-devel \
        json-c-devel \
        libusbx-devel \
        opencv-devel \
        asio-devel \
        nlohmann-json-devel \
        mbedtls-devel \
        libX11-devel \
        glib2-devel \
        pipewire-devel \
        ffmpeg-devel \
        gstreamer1-plugins-base-devel \
        libva-devel \
        libvdpau-devel \
        mesa-libGL-devel \
        libdrm-devel \
        libXext-devel \
        libXrandr-devel \
        glm-devel \
    && \
    dnf clean all

# Set the working directory inside the builder container for huenicorn's source code.
WORKDIR /app/huenicorn
# Clone the huenicorn source code from its Git repository.
RUN git clone https://gitlab.com/openjowelsofts/huenicorn.git .
# Create a 'build' directory, navigate into it, configure the build with CMake, and then compile the project with Make.
# This single RUN command ensures these steps are executed sequentially and efficiently in one layer.
RUN mkdir build && cd build && cmake .. && make


# --- Stage 2: Final Bootc Image ---
# This is the stage that defines your actual bootable operating system.
# It starts from your chosen Bazzite base image (e.g., bazzite-deck:latest).
# This image will be the one you ultimately deploy to your system.
FROM ghcr.io/ublue-os/bazzite-deck:latest

# Add RPM Fusion repositories to the final image for runtime libraries.
# This is essential if huenicorn's runtime (non-devel) dependencies, such as 'ffmpeg',
# are provided by RPM Fusion and are not part of the default Bazzite image.
# If your specific Bazzite variant already includes RPM Fusion, this step can be removed.
RUN dnf install -y \
    https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm \
    https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm \
    && dnf update -y

# Install ONLY runtime dependencies for huenicorn.
# These are the shared libraries (.so files) that huenicorn needs to execute after it has been compiled.
# Notice these are the non-'-devel' versions of the packages installed in the builder stage.
# - curl, json-c, libusbx, opencv, asio, mbedtls, libX11, glib2, pipewire, ffmpeg, gstreamer1-plugins-base,
#   libva, libvdpau, mesa-libGL, libdrm, libXext, libXrandr: These are the runtime libraries.
# - glm and nlohmann-json: These are typically header-only C++ libraries, meaning they don't require
#   a separate runtime package as their code is integrated during compilation.
# dnf clean all: Cleans up the dnf cache in the final image to keep its size minimal.
RUN dnf install -y \
    curl \
    json-c \
    libusbx \
    opencv \
    asio \
    mbedtls \
    libX11 \
    glib2 \
    pipewire \
    ffmpeg \
    gstreamer1-plugins-base \
    libva \
    libvdpau \
    mesa-libGL \
    libdrm \
    libXext \
    libXrandr \
    && \
    dnf clean all

# Copy the compiled huenicorn executable from the 'builder' stage to the final image.
# '--from=builder' specifies that the file comes from the named 'builder' stage.
# The executable is expected to be in '/app/huenicorn/build/huenicorn' within the builder stage.
# It's copied to '/usr/local/bin/huenicorn' in the final image, a standard location for binaries.
COPY --from=builder /app/huenicorn/build/huenicorn /usr/local/bin/huenicorn

# Set up the systemd service for huenicorn.
# mkdir -p /etc/systemd/system/: Ensures the directory exists.
# COPY systemd/huenicorn.service: Copies your custom systemd service file.
#   (You must have a 'systemd' directory in your local build context containing 'huenicorn.service').
# systemctl enable huenicorn.service: Enables the service so it starts automatically on boot.
RUN mkdir -p /etc/systemd/system/
COPY systemd/huenicorn.service /etc/systemd/system/huenicorn.service
RUN systemctl enable huenicorn.service

# Validate the bootc image.
# This command performs checks specific to bootc images to ensure they are properly
# structured and can be deployed and booted correctly. Highly recommended for universal-blue images.
RUN bootc container lint

# --- Universal Blue Template Boilerplate ---
# This section contains commands often used by Universal Blue's `build.sh` script
# for deeper system modifications (e.g., via `rpm-ostree`).
# If you are building this Containerfile directly (e.g., with `podman build` or `docker build`)
# and not using the full Universal Blue image-template's `build.sh` script, you might not
# need this section, or it might need specific context (like a populated `build_files` directory).
# If you are simply layering an application, the steps above are usually sufficient.
# Comment out if causing errors and you are not specifically using the `build.sh` method.
# RUN --mount=type=bind,from=ctx,source=/,target=/ctx \
#     --mount=type=cache,dst=/var/cache \
#     --mount=type=cache,dst=/var/log \
#     --mount=type=tmpfs,dst=/tmp \
#     /ctx/build.sh && \
#     ostree container commit

# RUN bootc container lint # This line is often duplicated in the boilerplate; one is sufficient.
